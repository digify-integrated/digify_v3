<?php

namespace App\Core;

/**
 * Class Security
 *
 * Provides utility methods for encryption, masking sensitive data,
 * secure token generation, filesystem safety, and CSRF protection.
 *
 * @package App\Core
 */
class Security
{
    /**
     * A secret key known only to the server, kept outside the database.
     * Store this in an environment variable or config file, not in code.
     */
    private const PEPPER = ENCRYPTION_KEY;

    /**
     * Hash a token (OTP, reset token, or session token).
     *
     * @param string $token  The raw token (e.g. a 6-digit OTP or random session token).
     * @return string        The hashed and peppered representation safe for DB storage.
     */
    public static function hashToken(string $token): string
    {
        // Mix in the server-side pepper before hashing.
        $peppered = hash_hmac('sha256', $token, self::PEPPER);

        // Use bcrypt/argon2id under the hood for strong, slow hashing.
        return password_hash($peppered, PASSWORD_DEFAULT);
    }

    /**
     * Verify a provided token against the stored hash.
     *
     * @param string $token       The token submitted by the user.
     * @param string $storedHash  The hashed token retrieved from the database.
     * @return bool               True if valid, false otherwise.
     */
    public static function verifyToken(string $token, string $storedHash): bool
    {
        $peppered = hash_hmac('sha256', $token, self::PEPPER);
        return password_verify($peppered, $storedHash);
    }

    /**
     * Generate a random reset or session token.
     *
     * @param int $lengthBytes  Number of random bytes to generate (default 32 â†’ 64 hex chars).
     * @return string           The raw token string (to send/store temporarily).
     */
    public static function generateToken(int $lengthBytes = 32): string
    {
        return bin2hex(random_bytes($lengthBytes));
    }

    /**
     * Generate a numeric OTP code.
     *
     * @param int $digits  Number of digits (default 6).
     * @return string      The zero-padded numeric OTP (e.g. "042381").
     */
    public static function generateOtp(int $digits = 6): string
    {
        $max = (10 ** $digits) - 1;
        return str_pad((string) random_int(0, $max), $digits, '0', STR_PAD_LEFT);
    }   

    /**
     * Encrypt plain text using AES-256-CBC.
     *
     * @param string $plainText Text to encrypt
     * @return string|false Encrypted string (base64 + URL encoded) or false on failure
     */
    public static function encryptData(string $plainText): string|false
    {
        $plainText = trim($plainText);
        if ($plainText === '') {
            return false;
        }

        $ivLength = openssl_cipher_iv_length('aes-256-cbc');
        $iv = random_bytes($ivLength);

        $ciphertext = openssl_encrypt(
            $plainText,
            'aes-256-cbc',
            self::PEPPER,
            OPENSSL_RAW_DATA,
            $iv
        );

        return $ciphertext
            ? rawurlencode(base64_encode($iv . $ciphertext))
            : false;
    }

    /**
     * Decrypt ciphertext generated by encryptData().
     *
     * @param string $ciphertext Encrypted string (base64 + URL encoded)
     * @return string|false Decrypted string or false on failure
     */
    public static function decryptData(string $ciphertext): string|false
    {
        $decodedData = base64_decode(rawurldecode($ciphertext), true);
        if ($decodedData === false) {
            return false;
        }

        $ivLength = openssl_cipher_iv_length('aes-256-cbc');
        if (strlen($decodedData) <= $ivLength) {
            return false;
        }

        $iv = substr($decodedData, 0, $ivLength);
        $cipherRaw = substr($decodedData, $ivLength);

        return openssl_decrypt(
            $cipherRaw,
            'aes-256-cbc',
            self::PEPPER,
            OPENSSL_RAW_DATA,
            $iv
        ) ?: false;
    }

    /**
     * Obscure an email address (e.g. j***e@example.com).
     *
     * @param string $email Email address
     * @return string Masked email
     */
    public static function obscureEmail(string $email): string
    {
        [$username, $domain] = explode('@', $email, 2);
        $maskedUsername = substr($username, 0, 1)
            . str_repeat('*', max(0, strlen($username) - 2))
            . substr($username, -1);

        return $maskedUsername . '@' . $domain;
    }

    /**
     * Obscure a card number (e.g. **** **** **** 1234).
     *
     * @param string $cardNumber Credit/debit card number
     * @return string Masked card number
     */
    public static function obscureCardNumber(string $cardNumber): string
    {
        $last4Digits = substr($cardNumber, -4);
        $masked = str_repeat('*', max(0, strlen($cardNumber) - 4));

        // Group into chunks of 4 for readability
        $maskedGrouped = implode(' ', str_split($masked, 4));

        return trim($maskedGrouped . ' ' . $last4Digits);
    }

    /**
     * Generate a random filename with alphanumeric characters.
     *
     * @param int $minLength Minimum length
     * @param int $maxLength Maximum length
     * @return string Random filename
     */
    public static function generateFileName(int $minLength = 4, int $maxLength = 8): string
    {
        $characters = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
        $length = random_int($minLength, $maxLength);

        $filename = '';
        for ($i = 0; $i < $length; $i++) {
            $filename .= $characters[random_int(0, strlen($characters) - 1)];
        }

        return $filename;
    }

    /**
     * Check if a directory exists and is writable. Creates if missing.
     *
     * @param string $directory Directory path
     * @return true|string Returns true if OK, or error message string
     */
    public static function directoryChecker(string $directory): true|string
    {
        if (!is_dir($directory)) {
            if (!mkdir($directory, 0755, true)) {
                return 'Error creating directory: ' . (error_get_last()['message'] ?? 'Unknown error');
            }
        } elseif (!is_writable($directory)) {
            return 'Directory exists but is not writable.';
        }

        return true;
    }
    
    /**
     * Generate a CSRF token and store it in the session (stable per form key).
     *
     * @param string $formKey Unique form identifier
     * @return string CSRF token
     */
    public static function generateCSRFToken(string $formKey = 'default'): string
    {
        if (session_status() !== PHP_SESSION_ACTIVE) {
            session_start();
        }

        if (!isset($_SESSION['csrf_tokens'][$formKey])) {
            $_SESSION['csrf_tokens'][$formKey] = bin2hex(random_bytes(32));
        }

        return $_SESSION['csrf_tokens'][$formKey];
    }

    /**
     * Generate a CSRF token input field for forms.
     *
     * @param string $formKey Unique form identifier
     * @return string HTML hidden input field
     */
    public static function csrfInput(string $formKey = 'default'): string
    {
        $token = self::generateCSRFToken($formKey);
        return '<input type="hidden" name="csrf_token" value="' . 
            htmlspecialchars($token, ENT_QUOTES, 'UTF-8') . '">';
    }

    /**
     * Validate a CSRF token from a request.
     *
     * @param string $token Token provided by the client
     * @param string $formKey Form identifier
     * @return bool True if valid, false otherwise
     */
    public static function validateCSRFToken(string $token, string $formKey = 'default'): bool
    {
        if (session_status() !== PHP_SESSION_ACTIVE) {
            session_start();
        }

        return isset($_SESSION['csrf_tokens'][$formKey]) &&
            hash_equals($_SESSION['csrf_tokens'][$formKey], $token);
    }

}
