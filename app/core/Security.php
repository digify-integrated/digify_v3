<?php

namespace App\Core;

/**
 * Class Security
 *
 * Provides utility methods for encryption, masking sensitive data,
 * secure token generation, filesystem safety, and CSRF protection.
 *
 * @package App\Core
 */
class Security {
    /**
     * A secret key known only to the server, kept outside the database.
     * Store this in an environment variable or config file, not in code.
     */
    private const PEPPER = ENCRYPTION_KEY;

    /**
     * Hash a token (OTP, reset token, or session token).
     *
     * @param string $token  The raw token (e.g. a 6-digit OTP or random session token).
     * @return string        The hashed and peppered representation safe for DB storage.
     */
    public static function hashToken(string $token) {
        // Mix in the server-side pepper before hashing.
        $peppered = hash_hmac('sha256', $token, self::PEPPER);

        // Use bcrypt/argon2id under the hood for strong, slow hashing.
        return password_hash($peppered, PASSWORD_DEFAULT);
    }

    /**
     * Verify a provided token against the stored hash.
     *
     * @param string $token       The token submitted by the user.
     * @param string $storedHash  The hashed token retrieved from the database.
     * @return bool               True if valid, false otherwise.
     */
    public static function verifyToken(string $token, string $storedHash) {
        $peppered = hash_hmac('sha256', $token, self::PEPPER);
        return password_verify($peppered, $storedHash);
    }

    /**
     * Generate a random reset or session token.
     *
     * @param int $lengthBytes  Number of random bytes to generate (default 32 â†’ 64 hex chars).
     * @return string           The raw token string (to send/store temporarily).
     */
    public static function generateToken(int $lengthBytes = 32) {
        return bin2hex(random_bytes($lengthBytes));
    }

    /**
     * Generate a numeric OTP code.
     *
     * @param int $digits  Number of digits (default 6).
     * @return string      The zero-padded numeric OTP (e.g. "042381").
     */
    public static function generateOtp(int $digits = 6) {
        $max = (10 ** $digits) - 1;
        return str_pad((string) random_int(0, $max), $digits, '0', STR_PAD_LEFT);
    }   

    /**
     * Encrypt plain text using AES-256-CBC.
     *
     * @param string $plainText Text to encrypt
     * @return string|false Encrypted string (base64 + URL encoded) or false on failure
     */
    public static function encryptData(string $plainText) {
        $plainText = trim($plainText);
        if ($plainText === '') {
            return false;
        }

        $ivLength   = openssl_cipher_iv_length('aes-256-cbc');
        $iv         = random_bytes($ivLength);

        $ciphertext = openssl_encrypt(
            $plainText,
            'aes-256-cbc',
            self::PEPPER,
            OPENSSL_RAW_DATA,
            $iv
        );

        return $ciphertext
            ? rawurlencode(base64_encode($iv . $ciphertext))
            : false;
    }

    /**
     * Decrypt ciphertext generated by encryptData().
     *
     * @param string $ciphertext Encrypted string (base64 + URL encoded)
     * @return string|false Decrypted string or false on failure
     */
    public static function decryptData(string $ciphertext) {
        $decodedData = base64_decode(rawurldecode($ciphertext), true);
        if ($decodedData === false) {
            return false;
        }

        $ivLength = openssl_cipher_iv_length('aes-256-cbc');
        if (strlen($decodedData) <= $ivLength) {
            return false;
        }

        $iv         = substr($decodedData, 0, $ivLength);
        $cipherRaw  = substr($decodedData, $ivLength);

        return openssl_decrypt(
            $cipherRaw,
            'aes-256-cbc',
            self::PEPPER,
            OPENSSL_RAW_DATA,
            $iv
        ) ?: false;
    }

    /**
     * Obscure an email address for display/logging (e.g. j***e@ex*****.com).
     *
     * - Masks most of the username but keeps first/last character (if length > 2).
     * - Masks part of the domain (leaving TLD visible).
     * - Handles short usernames safely.
     * - Returns "invalid email" placeholder if input is not a valid email.
     *
     * @param string $email Email address
     * @return string Masked email
     */
    public static function obscureEmail(string $email) {
        // Validate email
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            return '[invalid email]';
        }

        [$username, $domain] = explode('@', strtolower(trim($email)), 2);

        // --- Mask username ---
        if (strlen($username) <= 2) {
            // If username is too short, mask entirely
            $maskedUsername = str_repeat('*', strlen($username));
        } else {
            $maskedUsername = substr($username, 0, 1)
                . str_repeat('*', strlen($username) - 2)
                . substr($username, -1);
        }

        // --- Mask domain (keep TLD visible) ---
        $domainParts    = explode('.', $domain);
        $tld            = array_pop($domainParts);
        $maskedDomain   = '';

        foreach ($domainParts as $part) {
            $maskedDomain .= substr($part, 0, 2) . str_repeat('*', max(0, strlen($part) - 2)) . '.';
        }
        $maskedDomain .= $tld;

        return $maskedUsername . '@' . $maskedDomain;
    }

    /**
     * Obscure a card number (e.g. **** **** **** 1234).
     *
     * @param string $cardNumber Credit/debit card number
     * @return string Masked card number
     */
    public static function obscureCardNumber(string $cardNumber) {
        $last4Digits    = substr($cardNumber, -4);
        $masked         = str_repeat('*', max(0, strlen($cardNumber) - 4));
        $maskedGrouped  = implode(' ', str_split($masked, 4));

        return trim($maskedGrouped . ' ' . $last4Digits);
    }

    /**
     * Generate a random filename with alphanumeric characters.
     *
     * @param int $minLength Minimum length
     * @param int $maxLength Maximum length
     * @return string Random filename
     */
    public static function generateFileName(int $minLength = 4, int $maxLength = 8) {
        $characters     = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
        $length         = random_int($minLength, $maxLength);

        $filename = '';
        for ($i = 0; $i < $length; $i++) {
            $filename .= $characters[random_int(0, strlen($characters) - 1)];
        }

        return $filename;
    }

    /**
     * Check if a directory exists and is writable. Creates if missing.
     *
     * @param string $directory Directory path
     * @return true|string Returns true if OK, or error message string
     */
    public static function directoryChecker(string $directory) {
        if (!is_dir($directory)) {
            if (!mkdir($directory, 0755, true)) {
                return 'Error creating directory: ' . (error_get_last()['message'] ?? 'Unknown error');
            }
        } else if (!is_writable($directory)) {
            return 'Directory exists but is not writable.';
        }

        return true;
    }
    
    /**
     * Generate a CSRF token and store it in the session (stable per form key).
     *
     * @param string $formKey Unique form identifier
     * @return string CSRF token
     */
    public static function generateCSRFToken(string $formKey = 'default') {
        if (session_status() !== PHP_SESSION_ACTIVE) {
            session_start();
        }

        if (!isset($_SESSION['csrf_tokens'][$formKey])) {
            $_SESSION['csrf_tokens'][$formKey] = bin2hex(random_bytes(32));
        }

        return $_SESSION['csrf_tokens'][$formKey];
    }

    /**
     * Generate a CSRF token input field for forms.
     *
     * @param string $formKey Unique form identifier
     * @return string HTML hidden input field
     */
    public static function csrfInput(string $formKey = 'default') {
        $token = self::generateCSRFToken($formKey);
        return '<input type="hidden" name="csrf_token" value="' . 
            htmlspecialchars($token, ENT_QUOTES, 'UTF-8') . '">';
    }

    /**
     * Validate a CSRF token from a request.
     *
     * @param string $token Token provided by the client
     * @param string $formKey Form identifier
     * @return bool True if valid, false otherwise
     */
    public static function validateCSRFToken(string $token, string $formKey = 'default') {
        if (session_status() !== PHP_SESSION_ACTIVE) {
            session_start();
        }

        return isset($_SESSION['csrf_tokens'][$formKey]) &&
            hash_equals($_SESSION['csrf_tokens'][$formKey], $token);
    }

}
